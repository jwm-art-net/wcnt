wcnt-1.1001/jwmsynth  // <-- wcnt file identifier
// header info:
samplerate 	44100
bpm		160
signature 	4/4
// end of header.

// sampler01.wc will show you how to setup the sampler for good basic operation.
// it utilises several features:
//	* modulated start position when sample playback is triggered.
//	* relative loop points so loop is in a different place each time.
//	* forward only looping.
//	* anti-clipping to fade out and fade in when sample is retriggered, 
//	  and when loop jumps from end point to start point. 
//	* searches around start point and loop points, for the sample
//	  with a value closest to zero, and adjusts points to match.

// the sampler will *only* read 16 bit wav files.  it will automatically 
// adjust samplerates of wavs which differ from the samplerate in the
// header above, so that they sound as intended.  it will read stereo,
// aswell as mono wavs.


// setup the time_map
time_map
time1  
        time
		// add a signature change at bar 0
		signature	4/4	0
		// add a bpm change at bar 0, ramp bpm from bar 3 to bar 4.
		bpm 120	0
		bpm 120 3
		bpm 60 4
        time
time1

// setup how long to process:
wcnt_exit
wcnt_exit_module
        in_bar  time1 out_bar
	exit_bar 6		// process 5 bars, stop at beginning bar 6.
wcnt_exit_module

// first, create some riffs.  riffs are inserted into the sequencer, and 
// contain note patterns.  riffs are not modules.  The first job of a riff
// is to define the value you will use for a crotchet, or quarter note in 
// that riff, the value you use will determine what values you use for the 
// note lengths and note positions for all notes in the riff.

// currently the wcnt sequencer module is monophonic, one sequencer can play
// only one note at a time.  

riff 
riff1
	quarter_value	16 
	// quarter_value of 16 sets bar length to 64 when time signature is 4/4.
	//   notename	position	length	velocity
	note	c0	0		18.5	1.0
	note	g0	24		7	0.75
	note	f0	32		13.5	0.5
	note	d0	48		3.5	1.0
	note	d0	56		7.5	1.0
riff1

riff 
riff2
	quarter_value	16 
	note	c0	0		32	1.0
riff2


sequencer
seq1
        track // add four bars of riff1:
		riff1	0
		riff1	1
		riff1	2
		riff1	3
		riff2	4
        track
	// connect sequencer to keep in sync with time1 time_map module
        in_bar			time1	out_bar
        in_bar_trig     	time1	out_bar_trig
        in_pos_step_size        time1	out_pos_step_size
	// parameters for module: sequencer
        velocity_response_time  5	// take 5 ms to change velocity
        hold_notename		off	// ignore hold_notename
seq1

// sampler needs a deg_size to playback the sample at different rates.
// use an osc_clock to get it to playback at musical note frequencies.

osc_clock
osc1
	// connect with seq1 sequencer module.
        in_note_on_trig		seq1	out_note_on_trig
        in_note_slide_trig      seq1	out_note_slide_trig
        in_frequency    	seq1	out_frequency
        in_freq_mod1    	off
        in_freq_mod2    	off
        octave_offset		0
        tuning_semitones        0.00	
        portamento_time 	50.0	// duration of a note_slide event
        freq_mod1_size  	0.0
        freq_mod2_size  	0.0
osc1

// adsr to shape sampler output:

adsr
adsr1
        envelope
                attack	15.0	1.0	50.0	1.0
                decay   20.0	0.9	65.0	0.9
                release	345.0	0.0	420.0	0.0
        envelope
	// connect to sequencer triggers
        in_note_on_trig		seq1	out_note_on_trig
        in_note_off_trig        seq1	out_note_off_trig
	// nb don't use out_velocity_ramped here:
        in_velocity     	seq1	out_velocity 
        start_level     0.0
        sustain_state   on	// hold volume level from decay section until note_off
        zero_retrigger  off
adsr1

// couple of modules to modulate start position of sampler

clock
clock1
        in_freq_mod1    off
        freq    0.1
        freq_mod1_size  0.0
clock1

sine_wave
modsin1
        in_phase_trig   	clock1	out_phase_trig
        in_deg_size     	clock1	out_deg_size
        recycle_mode    	off
        on_trig_reset_phase     off
        phase_cycles    	1.0
modsin1

// note:  sine_wave produces a sine wave whose output oscillates
// between 1.0 and -1.0.  the  modulation of the start position 
// in the sampler module when the modulation input is negative, 
// inverts it so that -1.0 becomes 1.0 and -0.1 becomes 0.1 etc.

// when the adsr finishes, it generates an out_off_trig which the 
// sampler will use to stop playing.  this is not neccessary, but it
// stops the sampler activating the anticlipping when there is no 
// need for it.

// first define a wavfilein to tell the sampler what file to read.

wavfilein ms20 file samples/korgms20.wav ms20

//  korgms20.wav contains 193118 samples

// whuh, sampler looks complicated:

sampler
sampler1

//inputs for module: sampler
        in_play_trig    	seq1	out_note_on_trig
        in_stop_trig    	adsr1	out_off_trig
        in_start_pos_mod	modsin1	out_output
        in_deg_size     	osc1	out_deg_size

// parameters for module: sampler
        wavfile 	ms20
        play_dir        fwd
        play_mode       wrap	// not relevent to this setup, but must be set.
        jump_mode       play	// not relevent to this setup.
        start_pos_min   0	
        start_pos_max   80000
        loop_mode       fwd
        loop_start_pos  10000
        loop_end_pos    15000
        loop_is_offset  on	// loop points relative to start point
        bi-directional_offset   0	// used when play direction changes
        anti_clip_samples       175	// fade out/in samples
        anti_clip_each_end      on	// 
        zero_search_range       150	// how many samples to search for zero X
        root_note       c0
        degsize_amount  1.0	// how much to follow frequencies (deg_size)
sampler1

// note:  because anti_clip_each_end is on, the sampler adjusts the 
// minumum and maximum samples which can be played, this gives the
// anticlipping code something to playback, otherwise it would have
// to read past the start when playback is reverse, and the end when
// playback is forward.  when anti_clip_each_end is off, it does not
// anticlip these extremes.

// note:  degsize_amount
// a value of 0.0 will always playback the sample at it's natural rate.
// a value of 1.0 will play it back at the western equal temperment scale
//	(providing the deg_size is of western musical notes)
// a value of less than 1.0 will play it back at microtonal scales
// a value greater than 1.0 will ??? (don't know what it's called!)

// outputs for module: sampler
// out_left	// output integer value, as in wav
// out_right
// out_l	// output converted to -1.0 to +1.0 range
// out_r
// out_loop_trig
// out_play_state

// for mono samples, left and right outputs are the same.

mono_amp
amp1
	in_signal	sampler1	out_l
	in_amp_eg	adsr1		out_output
	in_amp_mod	seq1		out_velocity_ramp
	amplitude	32767	// 32767 is the maximum amplitude
	amp_mod_size	0.95	// how much influence velocity has in this case
	clip_level	25000	// the maximum allowed amplitude
amp1

// wavfile_out module.  a wcnt file without atleast one of these modules is 
// as good as useless.  It has an in_bar_trig aswell as an in_bar input 
// to stop it from thinking every sample in a bar is a new bar. 
// And Why Not? (tm)

wavfile_out
wav1
	in_left		amp1	out_mono
	in_right	amp1	out_mono
	in_bar		time1	out_bar
	in_bar_trig	time1	out_bar_trig
	filename	sampler01.wav
	start_bar	0
	end_bar		5 
wav1

// Although there are only four bars in the sequencer, wav1 stops writing when
// bar 5 is reached because the release time of the ADSR causes audible sound 
// to last beyond the end bar 3 and into bar 4.

wcnt-1.1001/jwmsynth
