wcnt-1.1za/jwmsynth  // <-- wcnt file identifier
//----------------------------------------------------------------------------

header time.wc  // loader header from time.wc and not here.

//-----------------------------------------------------------------------------
// sampler01.wc will show you how to setup the sampler for good basic operation.
// it utilises several features:
//	* modulated start position when sample playback is triggered.
//	* relative loop points so loop is in a different place each time.
//	* forward only looping.
//	* anti-clipping to fade out and fade in when sample is retriggered, 
//	  and when loop jumps from end point to start point. 
//	* searches around start point and loop points, for the sample
//	  with a value closest to zero, and adjusts points to match.

// the sampler will *only* read 16 bit wav files.  it will automatically 
// adjust samplerates of wavs which differ from the samplerate in the
// header above, so that they sound as intended.  it will read stereo,
// aswell as mono wavs.


// setup the time_map
time_map
time1  
        meter_map
		meter
			tsig	4/4	bar	0
	meter_map
	bpm_map
		tempo
			bpm	160	bar	2
		tempo
			bpm 	120	bar	3
		tempo
			bpm 	160	bar	3
		tempo
			bpm	160	bar	6
		tempo
			bpm 	120	bar	7
	bpm_map
time1

// first, create some riffs.  riffs are inserted into the sequencer, and 
// contain note patterns.  riffs are not modules.  The first job of a riff
// is to define the value you will use for a crotchet, or quarter note in 
// that riff, the value you use will determine what values you use for the 
// note lengths and note positions for all notes in the riff.

// currently the wcnt sequencer module is monophonic, one sequencer can play
// only one note at a time.  And a riff can only handle one note at a time.

riff 
riff1
	quarter_value	16
	note	
		name	c0	pos	0	len	18.5	vel	1.0
	note	
		name	g0	pos	24	len	7	vel	0.75
	note		
		name	f0	pos	32	len	13.5	vel	0.5
	note		
		name	d0	pos	48	len	7.5	vel	1.0
	note		
		name	d0	pos	56	len	7.5	vel	0.8
riff1

riff 
riff2
	quarter_value	16 
	note	
		name	c0	pos	0	len	32	vel	1.0
riff2

// now insert the riffs into the sequencer.  some of the inserted riffs have 
// been transposed and the note lengths have been modified, at some bars

sequencer
seq1
        track
		riff_node
			riff	riff1	bar	0
			transpose	0	start_len	0	end_len	0
		riff_node
			riff	riff1	bar	1
			transpose	-1	start_len	0	end_len	8

		riff_node
			riff	riff1	bar	2
			transpose	0	start_len	0	end_len	0

		riff_node
			riff	riff1	bar	3
			transpose	1	start_len	0	end_len	-6

		riff_node
			riff	riff1	bar	4
			transpose	0	start_len	0	end_len	0

		riff_node
			riff	riff1	bar	5
			transpose	-1	start_len	8	end_len	0

		riff_node
			riff	riff1	bar	6
			transpose	0	start_len	0	end_len	0

		riff_node
			riff	riff1	bar	7
			transpose	1	start_len	-6	end_len	0

		riff_node
			riff	riff2	bar	8
			transpose	0	start_len	0	end_len	0
        track

        in_bar			time1	out_bar
        in_bar_trig     	time1	out_bar_trig
        in_pos_step_size        time1	out_pos_step_size
	in_beats_per_bar	time1	out_beats_per_bar
	in_beat_value		time1	out_beat_value

        velocity_response_time  5	// take 5 ms to change velocity
        hold_notename		off	// ignore hold_notename
seq1

// adsr to shape sampler output.  the lower shape is 'slower', and is triggered
// by velocities of 0.5 and below, the upper shape is faster and triggered by
// high velocities of 1.0

adsr
adsr1
        envelope
		section	name	attack	
			ut	15.0	ul	1.0
			lt	150.0	ll	1.0

                section	name	decay	
			ut	20.0	ul	0.9
			lt	165.0	ll	0.9

                section	name	release	
			ut	745.0	ul	0.0
			lt	120.0	ll	0.0
        envelope

        in_note_on_trig		seq1	out_note_on_trig
        in_note_off_trig        seq1	out_note_off_trig
        in_velocity     	seq1	out_velocity 

	up_thresh	0.9
	lo_thresh	0.5
        start_level     0.0
        sustain_state   on
        zero_retrigger  off
adsr1

// sampler needs a deg_size to playback the sample at different rates.
// use an osc_clock to get it to playback at musical note frequencies.
// there are two osc_clocks, the second being slightly detuned.

osc_clock
osc1
	// connect with seq1 sequencer module.
        in_note_on_trig		seq1	out_note_on_trig
        in_note_slide_trig      seq1	out_note_slide_trig
        in_frequency    	seq1	out_frequency
        in_freq_mod1    	off
        in_freq_mod2    	off
        octave_offset		0
        tuning_semitones        0.00	
        portamento_time 	50.0	// duration of a note_slide event
        freq_mod1_size  	0.0
        freq_mod2_size  	0.0
osc1

osc_clock
osc2
	// connect with seq1 sequencer module.
        in_note_on_trig		seq1	out_note_on_trig
        in_note_slide_trig      seq1	out_note_slide_trig
        in_frequency    	seq1	out_frequency
        in_freq_mod1    	off
        in_freq_mod2    	off
        octave_offset		0
        tuning_semitones        0.05
        portamento_time 	50.0	// duration of a note_slide event
        freq_mod1_size  	0.0
        freq_mod2_size  	0.0
osc2

// couple of modules to modulate start position of sampler

clock
clock1
        in_freq_mod1    off
        freq    0.1
        freq_mod1_size  0.0
clock1

sine_wave
modsin1
        in_phase_trig   	clock1	out_phase_trig
        in_deg_size     	clock1	out_deg_size
        recycle_mode    	off
        on_trig_reset_phase     off
        phase_cycles    	1.0
modsin1

// note:  sine_wave produces a sine wave whose output oscillates
// between 1.0 and -1.0.  the  modulation of the start position 
// in the sampler module when the modulation input is negative, 
// inverts it so that -1.0 becomes 1.0 and -0.1 becomes 0.1 etc.

// when the adsr finishes, it generates an out_off_trig which the 
// sampler will use to stop playing.  this is not neccessary, but it
// stops the sampler activating the anticlipping when there is no 
// need for it.

// first define a wavfilein to tell the sampler what file to read.
// korgms20.wav contains 193118 samples

wavfilein 
ms20 
	filename	samples/korgms20.wav 
        root_note       c0
ms20

sampler
sampler1
        in_play_trig    	seq1	out_note_on_trig
        in_stop_trig    	adsr1	out_off_trig
        in_start_pos_mod	modsin1	out_output
        in_deg_size     	osc1	out_deg_size

        wavfile 		ms20
        play_dir        	fwd
        play_mode       	wrap	// not relevent to this setup, but must be set.
        jump_mode       	play	// not relevent to this setup.
        start_pos_min   	0	
        start_pos_max   	80000
        loop_mode       	fwd
        loop_start_pos  	10000
        loop_end_pos    	15000
        loop_is_offset  	on	// loop points relative to start point
        bi-directional_offset   0	// used when play direction changes
        anti_clip_samples       175	// fade out/in samples
        anti_clip_each_end      on	// 
        zero_search_range       150	// how many samples to search for zero X
        degsize_amount  	1.0	// how much to follow frequencies (deg_size)
sampler1

// the detuned sampler:

sampler
sampler2
        in_play_trig    	seq1	out_note_on_trig
        in_stop_trig    	adsr1	out_off_trig
        in_start_pos_mod	modsin1	out_output
        in_deg_size     	osc2	out_deg_size

        wavfile 		ms20
        play_dir        	fwd
        play_mode       	wrap	// not relevent to this setup, but must be set.
        jump_mode       	play	// not relevent to this setup.
        start_pos_min   	0	
        start_pos_max   	80000
        loop_mode       	fwd
        loop_start_pos  	10000
        loop_end_pos    	15000
        loop_is_offset  	on	// loop points relative to start point
        bi-directional_offset   0	// used when play direction changes
        anti_clip_samples       175	// fade out/in samples
        anti_clip_each_end      on	// 
        zero_search_range       150	// how many samples to search for zero X
        degsize_amount  	1.0	// how much to follow frequencies (deg_size)
sampler2

// note:  because anti_clip_each_end is on, the sampler adjusts the 
// minumum and maximum samples which can be played, this gives the
// anticlipping code something to playback, otherwise it would have
// to read past the start when playback is reverse, and the end when
// playback is forward.  when anti_clip_each_end is off, it does not
// anticlip these extremes.

// note:  degsize_amount
// a value of 0.0 will always playback the sample at it's natural rate.
// a value of 1.0 will play it back at the western equal temperment scale
//	(providing the deg_size is of western musical notes)
// a value of less than 1.0 will play it back at microtonal scales
// a value greater than 1.0 will ??? (don't know what it's called!)

// outputs for module: sampler
// out_left	// output integer value, as in wav
// out_right
// out_l	// output converted to -1.0 to +1.0 range
// out_r
// out_loop_trig
// out_play_state

// for mono samples, left and right outputs are the same.

stereo_amp
amp1
	in_l		sampler1	out_l
	in_r		sampler2	out_l
	in_amp_eg	adsr1		out_output
	in_amp_mod	seq1		out_velocity_ramp

	left_amplitude	32000		// 32767 is the maximum amplitude
	right_amplitude	32000		// 32767 is the maximum amplitude
	amp_mod_size	0.95		// how much influence velocity has in this case
	clip_level	32767		// the maximum allowed amplitude
amp1

wavfile_out
wav1
	in_left		amp1	out_left
	in_right	amp1	out_right
	in_bar		time1	out_bar
	in_bar_trig	time1	out_bar_trig

	filename	sampler01.wav
	start_bar	0
	end_bar		9
wav1

// setup how long to process:

wcnt_exit
wcnt_exit_module
        in_bar		time1	out_bar
	exit_bar	9
wcnt_exit_module

wcnt-1.1za/jwmsynth
