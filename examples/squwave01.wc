wcnt-1.1001/jwmsynth  // <-- wcnt file identifier
// header info:
samplerate 	44100
bpm		120
signature 	4/4
// end of header.

// this file takes from basics04.wc what was happening with the square wave
// and pushes it a little bit further....(pushing the envelope?)

time_map
time1  
        time
        time
time1

wcnt_exit
wcnt_exit_module
        in_bar  time1 out_bar
	exit_bar 34
wcnt_exit_module

riff 
riff1
	quarter_value	16
	//   notename	position	length	velocity
	note	c0	0		26.5	1.0
	note	d0	56		3.0	1.0
	note	f0	96		12	0.75
	note	c0	128		32	0.5
	note	d0	224		3.5	1.0
riff1


riff 
riff2
	quarter_value	16
	//   notename	position	length	velocity
	note	c0	0		46.5	1.0
	note	d0	56		6.5	1.0
	note	b0	80		24.5	1.0
	note	f0	144		12	0.75
	note	d0	192		7.5	1.0
riff2

sequencer
seq1
        track // add four bars of riff1:
		riff1	0
		riff2	4
		riff1	8
		riff2	12
		riff1	16
		riff2	20
		riff1	24
		riff2	28
        track
	// connect sequencer to keep in sync with time1 time_map module
        in_bar			time1	out_bar
        in_bar_trig     	time1	out_bar_trig
        in_pos_step_size        time1	out_pos_step_size
	// parameters for module: sequencer
        velocity_response_time  5	// take 5 ms to change velocity
        hold_notename		off  // does nothing yet.
seq1

lfo_clock
lfoclock1
        in_phase_trig   off //seq1	out_note_on_trig
        in_freq_mod1    off
        in_freq_mod2    off
        freq    	1.25
        freq_mod1_size  0.0
        freq_mod2_size  0.0
lfoclock1

// lfoclock, is another differentation of the clock modules. it is 
// somewhere, in function, between the clock and the osc_clock module, with
// a phase trigger added.  I saw no reason to restrict the lfo_clock to low 
// frequency oscilations though.

sine_wave
lfowave										
	in_phase_trig	lfoclock1	out_phase_trig
	in_deg_size	lfoclock1	out_deg_size
	recycle_mode		off 				
	on_trig_reset_phase	on
	phase_cycles 1.0					
lfowave

// in order to take advantage of the lfo's ability to reset it's phase,
// the sine_wave has on_trig_reset_phase ON.

// the final part of the lfo is to impliment a delay and a ramp of the
// oscillations.  lfo_controller does that job, and a further amplitude 
// modulation can be added also.

// ramp the amount of modulation from zero at the beginning of each note,
// to increase as time progresses.

lfo_controller
lforamp
        in_trig 	seq1	out_note_on_trig
        in_waveform     lfowave	out_output
        in_amp_mod      off
        delay_time      15.0 // 75.0 ms
        ramp_time       50.0 // 100.0 ms
        start_level     0.0
        end_level       1.0
	response_time	5.0	
        amp_mod_size    0.0
lforamp

// create adsr for use with osc_clock pitch modulation
// notice the parameter differences between this adsr, and those
// that have been used so far.  As the sustain section is not in
// use, in_note_off_trig is ignored. 

adsr
pm_adsr
        envelope
                attack	2.5	1.0	5.0	1.0
                decay   20.0	0.8	35.0	0.8
		release	35.0	0.4	45.0	0.4
                release	135.0	0.0	150.0	0.0
        envelope
        in_note_on_trig		seq1	out_note_on_trig
        in_note_off_trig        off
        in_velocity     	seq1	out_velocity 
        start_level     0.8
        sustain_state   off	// don't include sustain
        zero_retrigger  off	// don't always start at start_level
pm_adsr

// adsr for volume envelope

adsr
adsr1
        envelope
                attack	5.0	1.0	15.0	1.0
                decay   20.0	0.8	35.0	0.8
		decay	25.0	0.3	20.0	0.3
		release	185.0	0.15	145.0	0.15
                release	245.0	0.0	215.0	0.0
        envelope
	// connect to sequencer triggers
        in_note_on_trig		seq1	out_note_on_trig
        in_note_off_trig        seq1	out_note_off_trig
	// nb don't use out_velocity_ramped here:
        in_velocity     	seq1	out_velocity 
        start_level     0.0
        sustain_state   on	// hold decay volume level until note_off?
        zero_retrigger  off
adsr1

osc_clock
osc1
	// connect with seq1 sequencer module.
        in_note_on_trig		seq1		out_note_on_trig
        in_note_slide_trig      seq1		out_note_slide_trig
        in_frequency    	seq1		out_frequency
        in_freq_mod1    	pm_adsr		out_output
        in_freq_mod2    	off
        octave_offset		0
        tuning_semitones        0.00	
        portamento_time 	25.0
        freq_mod1_size  	1.25	
        freq_mod2_size  	0.00
osc1

// wow, it's a pulse width modulated square wave.  the most digital square
// wave ever, it's output is strictly -1 **OR** +1.

square_wave
squ1
        in_phase_trig   osc1	out_phase_trig
        in_deg_size     osc1	out_deg_size
        in_pwm  	lforamp	out_output 
        pulse_width     0.5	// fully balanced pulse
        pwm_size        0.90	// how much to change pulse width
        recycle_mode    off
squ1

// apply volume envelope to the square wave using multiplier and adsr

multiplier
squ*adsr
	in_signal	squ1	out_output
	in_modifier	adsr1	out_output
squ*adsr

// AND put the square_wave through a series of low pass filters which obtain
// their frequencies from a modified out_deg_size from osc1, instead of 
// creating clock modules

constant one value 1.0 one
constant two value 5.14 two

// the names of these modules were derived from when the value of constant
// module two, was actually 2, but when the square wave was filtered, it
// produced a not very varied result...

clock
lpfclock
//inputs for module: clock
        in_freq_mod1    lforamp	out_output
        freq    220
        freq_mod1_size  4.0
lpfclock

multiplier 
+1oct
	in_signal	lpfclock	out_deg_size
	in_modifier	two		out_output
+1oct

multiplier 
+2oct
	in_signal	+1oct	out_output
	in_modifier	two	out_output
+2oct

multiplier 
+4oct
	in_signal	+2oct	out_output
	in_modifier	two	out_output
+4oct

lp_filter
lpf1
        in_signal		squ*adsr	out_output
        in_cutoff_degsize       +1oct		out_output
        in_feedback     	lpf1		out_wet_output
        in_feedback_mod 	off	// input to modulate feedback level
        feedback		0.65	// amount of feedback 0 ~ 1.0
        feedback_modsize        0.00	// modulation size 0 ~ 1.0
        wet/dry 		1.0 	// 1.0 is wet 0.0 is dry
lpf1

lp_filter
lpf2
        in_signal		lpf1	out_output
        in_cutoff_degsize       +2oct	out_output
        in_feedback     	lpf2	out_wet_output	
        in_feedback_mod 	off	// input to modulate feedback level
        feedback		0.50	// amount of feedback 0 ~ 1.0
        feedback_modsize        0.00	// modulation size 0 ~ 1.0
        wet/dry 		1.0 // 1.0 is wet 0.0 is dry
lpf2

lp_filter
lpf3
        in_signal		lpf2	out_output
        in_cutoff_degsize       +4oct	out_output
        in_feedback     	lpf3	out_wet_output
        in_feedback_mod 	off	// input to modulate feedback level
        feedback		0.25	// amount of feedback 0 ~ 1.0
        feedback_modsize        0.00	// modulation size 0 ~ 1.0
        wet/dry 		1.0 // 1.0 is wet 0.0 is dry
lpf3

// all the low pass filters conspire to render the waveform as if it
// is riding a sub-sonic wave, let's use a high pass filter to get rid
// of it, but without cutting out too much of the audible low frequency.

constant 80hrtz_degsz value 0.65306122 80hrtz_degsz

hp_filter
hpf1
        in_signal       	lpf3		out_output
        in_cutoff_degsize       80hrtz_degsz	out_output
        in_feedback     	off
        in_feedback_mod 	off
        feedback        	0.0
        feedback_modsize        0.0
        wet/dry 		1.0
hpf1

// and yet another low pass, because the previous low pass filters
// had pitch modulated sources, and they're not that good at dealing
// with it, without producing slight tiks.

constant 5000_degsz value 40.816327 5000_degsz

lp_filter
lpf4
        in_signal		hpf1		out_output
        in_cutoff_degsize       5000_degsz	out_output
        in_feedback     	off
        in_feedback_mod 	off
        feedback		0.0
        feedback_modsize        0.0
        wet/dry 		1.0 // 1.0 is wet 0.0 is dry
lpf4

// now shove it all through an echo.... or two with range_limit on outputs
// but first we'll do some panning...

panner
pan1
	in_signal	lpf4	out_output
        in_pan_mod      lfowave	out_output
        pan     	0.00
        pan_mod_size    0.95
pan1

// create ping-pong echo by feeding left echo into right echo's feedback, and,
// feeding right echo into left echo's feedback...both of which are passed
// through a range limiter to control excess feedback to some degree:
// 	effectively clipping the signal to within -1 ~ +1

echo
ek01_l
        in_signal       pan1		out_l
        in_gain_mod     off
        in_feedback     rlek01_r	out_output
        in_feedback_mod off
        delay_time      	621.76
        gain    		0.35
        gain_modsize    	0.0
        feedback        	0.55
        feedback_modsize        0.0
        wet/dry 		0.75
ek01_l

echo
ek01_r
        in_signal       pan1		out_r
        in_gain_mod     off
        in_feedback     rlek01_l	out_output
        in_feedback_mod off
        delay_time      	546.33
        gain    		0.35
        gain_modsize    	0.0
        feedback        	0.55
        feedback_modsize        0.0
        wet/dry 		0.75
ek01_r

range_limit
rlek01_l
        in_signal       ek01_l	out_wet_output
        sig_range_hi    1.0
        sig_range_lo    -1.0
rlek01_l


range_limit
rlek01_r
        in_signal       ek01_r	out_wet_output
        sig_range_hi    1.0
        sig_range_lo    -1.0
rlek01_r

echo
ek02_l
        in_signal       ek01_l	out_wet_output
        in_gain_mod     off
        in_feedback     rlek02_r	out_output
        in_feedback_mod off
        delay_time      	334.75
        gain    		0.35
        gain_modsize    	0.0
        feedback        	0.25
        feedback_modsize        0.0
        wet/dry 		0.75
ek02_l

echo
ek02_r
        in_signal       ek01_r	out_wet_output
        in_gain_mod     off
        in_feedback     rlek02_l	out_output
        in_feedback_mod off
        delay_time      	255.98
        gain    		0.35
        gain_modsize    	0.0
        feedback        	0.25
        feedback_modsize        0.0
        wet/dry 		0.75
ek02_r

range_limit
rlek02_l
        in_signal       ek02_l	out_wet_output
        sig_range_hi    1.0
        sig_range_lo    -1.0
rlek02_l


range_limit
rlek02_r
        in_signal       ek02_r	out_wet_output
        sig_range_hi    1.0
        sig_range_lo    -1.0
rlek02_r

// amplified source signal
stereo_amp
amp1
	in_l		pan1	out_l
	in_r		pan1	out_r
	in_amp_eg	one	out_output
	in_amp_mod	off
	left_amplitude	5000
	right_amplitude	5000
	amp_mod_size	0.0
	clip_level	32000
amp1

// amplified wet echoed source
stereo_amp	
amp_ek1		// uses wet output as already have dry
	in_l		ek01_l	out_wet_output
	in_r		ek01_r	out_wet_output
	in_amp_eg	one	out_output
	in_amp_mod	off
	left_amplitude	5000
	right_amplitude	5000
	amp_mod_size	0.0
	clip_level	32000
amp_ek1

// amplified wet echoed source
stereo_amp	
amp_ek2		// uses wet output as already have dry
	in_l		ek02_l	out_wet_output
	in_r		ek02_r	out_wet_output
	in_amp_eg	one	out_output
	in_amp_mod	off
	left_amplitude	5000
	right_amplitude	5000
	amp_mod_size	0.0
	clip_level	32000
amp_ek2

mix_chan
ch1 
	in_left		amp1	out_left 
        in_right        amp1	out_right
ch1

mix_chan
ch_ek1
        in_left		amp_ek1	out_left
        in_right        amp_ek1	out_right
ch_ek1

mix_chan
ch_ek2
        in_left		amp_ek1	out_left
        in_right        amp_ek1	out_right
ch_ek2

mixer
mixer1
        mixdesk
		ch1 ch_ek1 ch_ek2
        mixdesk
        master_level    0.6
mixer1

wavfile_out
wav1
	in_left		mixer1	out_left
	in_right	mixer1	out_right
	in_bar		time1	out_bar
	in_bar_trig	time1	out_bar_trig
	filename	squwave01.wav
	start_bar	0
	end_bar		33
wav1

wcnt-1.1001/jwmsynth
