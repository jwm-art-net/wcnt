wcnt-1.1001/jwmsynth  // <-- wcnt file identifier
// header info:
samplerate 	44100
bpm		160
signature 	4/4
// end of header.

// basics03.wc produced four bars of audio with a repeating pattern
// of notes.  Each note responded to velocity and had pitch modulation
// to produce a vibrato effect.

// Unfortunately it still did not sound very interesting:
//	1) it only used a sine wave
//	2) no stereo panning
//	3) no layering of sounds from other wave forms

// in this wc file, the above points will be addressed.  It will introduce
// a lot more modules to you, and you will start to get an idea of what
// wcnt can produce.

// infact it's not so much the basic basics anymore.

// setup the time_map
time_map
time1  
        time
		// add a signature change at bar 0
		signature	4/4	0
		// add a bpm change at bar 0, ramp bpm from bar 3 to bar 4.
		bpm 120	0
        time
time1

// setup how long to process:
wcnt_exit
wcnt_exit_module
        in_bar  time1 out_bar
	exit_bar 6
wcnt_exit_module

// first, create some riffs.  riffs are inserted into the sequencer, and 
// contain note patterns.  riffs are not modules.  The first job of a riff
// is to define the value you will use for a crotchet, or quarter note in 
// that riff, the value you use will determine what values you use for the 
// note lengths and note positions for all notes in the riff.

// currently the wcnt sequencer module is monophonic, one sequencer can play
// only one note at a time.  

riff 
riff1
	quarter_value	16
	//   notename	position	length	velocity
	note	c0	0		7.5	1.0
	note	d0	8		4.5	1.0
	note	e0	16		7.5	1.0
	note	f0	24		4	0.75
	note	g0	32		3.5	0.5
	note	a1	36		8.5	1.0
	note	b1	40		8.5	1.0
	note	c1	48		8.5	1.0
	note	d1	56		5.5	1.0
riff1

// notice how from position 32, the notes will overlap, ie the notes are
// longer than the seperation between them.  this will cause the pitch of
// the notes to 'slide' up to the next, rather than jumping in pitch
// instantly. This is known as portamento.

sequencer
seq1
        track // add four bars of riff1:
		riff1	0
		riff1	1
		riff1	2
		riff1	3
        track
	// connect sequencer to keep in sync with time1 time_map module
        in_bar			time1	out_bar
        in_bar_trig     	time1	out_bar_trig
        in_pos_step_size        time1	out_pos_step_size
	// parameters for module: sequencer
        velocity_response_time  5	// take 5 ms to change velocity
        hold_notename		off	// ignore hold_notename
seq1

clock
vibratoclock
        in_freq_mod1    off	// we won't modulate the modulation rate.
        freq    	14
        freq_mod1_size	0.0
vibratoclock

sine_wave
vibratowave										
	in_phase_trig	vibratoclock	out_phase_trig
	in_deg_size	vibratoclock	out_deg_size
	recycle_mode		off 				
	on_trig_reset_phase	off 				
	phase_cycles 1.0
vibratowave

// won't use an lfoclock module for this...

clock
lfoclock2
        in_freq_mod1    off	// we won't modulate the modulation rate.
        freq    	0.371375
        freq_mod1_size	0.0
lfoclock2

sine_wave
lfowave2
	in_phase_trig	lfoclock2	out_phase_trig
	in_deg_size	lfoclock2	out_deg_size
	recycle_mode		off 				
	on_trig_reset_phase	off
	phase_cycles 1.0					
lfowave2

osc_clock
osc1
	// connect with seq1 sequencer module.
        in_note_on_trig		seq1		out_note_on_trig
        in_note_slide_trig      seq1		out_note_slide_trig
        in_frequency    	seq1		out_frequency
        in_freq_mod1    	vibratowave	out_output
        in_freq_mod2    	off
        octave_offset		-1
        tuning_semitones        0.00	
        portamento_time 	50.0	// duration of a note_slide event
        freq_mod1_size  	1.05	// small amount of modulation
        freq_mod2_size  	0.00
osc1

sine_wave
swave										
	in_phase_trig	osc1	out_phase_trig
	in_deg_size	osc1	out_deg_size
	recycle_mode		off 				
	on_trig_reset_phase	off 				
	phase_cycles 1.0					
swave

// a bit more info on the sine wave now.  in_phase_trig triggers the start
// of the waveform.  recycle_mode, when ON the waveform will not turn it's self
// off after completing one cycle of the waveform, you may want this when the
// phase trig is from a source driven at a lower frequency than that of the 
// degsize.  on_trig_reset_phase, when off 360 degrees is subtracted from the
// present degree upon trigger, when ON, the degrees are reset to zero.  
// for general usage it is best OFF because a cycle only in extremely rare 
// cases lasts a whole number of samples.  phase_cycles tells how many cycles
// to output, used in conjunction with recycle_mode ON, and differing sources
// for in_phase_trig, and in_deg_size.

// create another osc_clock with different tuning

osc_clock
osc2
	// connect with seq1 sequencer module.
        in_note_on_trig		seq1		out_note_on_trig
        in_note_slide_trig      seq1		out_note_slide_trig
        in_frequency    	seq1		out_frequency
        in_freq_mod1    	vibratowave	out_output
        in_freq_mod2    	off
        octave_offset		-1
        tuning_semitones        0.01	
        portamento_time 	15.0	// duration of a note_slide event
        freq_mod1_size  	1.05	// small amount of modulation
        freq_mod2_size  	0.00
osc2

// don't get too excited it's only a triangle waveform:
tri_wave
triwave1
        in_phase_trig   osc2	out_phase_trig
        in_deg_size     osc2	out_deg_size
        recycle_mode    off
        zero_retrigger  off
triwave1

// use three echo modules which feed into each other, with the first feeding
// back into the last.

echo
echo1
        in_signal       triwave1	out_output
        in_gain_mod     adsr1		out_output
        in_feedback     echo2		out_output
        in_feedback_mod off
        delay_time      	234.56
        gain			0.75
        gain_modsize    	1.0
        feedback        	0.75
        feedback_modsize        0.0
        wet/dry 		0.65
echo1

echo
echo2
        in_signal       echo1		out_output
        in_gain_mod     off
        in_feedback     echo3		out_output
        in_feedback_mod off
        delay_time      	123.45
        gain			0.75
        gain_modsize    	0.0
        feedback        	0.60
        feedback_modsize        0.0
        wet/dry 		0.65
echo2

echo
echo3
        in_signal       echo2		out_output
        in_gain_mod     off
        in_feedback     echo1		out_output
        in_feedback_mod off
        delay_time      	67.89
        gain			0.75
        gain_modsize    	0.0
        feedback        	0.45
        feedback_modsize        0.0
        wet/dry 		0.65
echo3

// create yet another osc_clock running an octave higher than original

osc_clock
osc3
	// connect with seq1 sequencer module.
        in_note_on_trig		seq1		out_note_on_trig
        in_note_slide_trig      seq1		out_note_slide_trig
        in_frequency    	seq1		out_frequency
        in_freq_mod1    	vibratowave	out_output
        in_freq_mod2    	off
        octave_offset		0
        tuning_semitones        -6.00	
        portamento_time 	150.0	// duration of a note_slide event
        freq_mod1_size  	1.05	// small amount of modulation
        freq_mod2_size  	0.0
osc3

// for simplicity use the same adsr for all sounds
// added an extra release section into the adsr..

adsr
adsr1
        envelope
                attack	5.0	1.0	15.0	1.0
                decay   20.0	0.8	35.0	0.8
		release	35.0	0.4	45.0	0.4
                release	135.0	0.0	150.0	0.0
        envelope
	// connect to sequencer triggers
        in_note_on_trig		seq1	out_note_on_trig
        in_note_off_trig        seq1	out_note_off_trig
	// nb don't use out_velocity_ramped here:
        in_velocity     	seq1	out_velocity 
        start_level     0.0
        sustain_state   on	// hold decay volume level until note_off?
        zero_retrigger  off
adsr1

// wow, it's a pulse width modulated square wave.  the most digital square
// wave ever, it's output is strictly -1 **OR** +1.

square_wave
squ1
        in_phase_trig   osc3		out_phase_trig
        in_deg_size     osc3		out_deg_size
        in_pwm  	lfowave2	out_output 
        pulse_width     0.5	// fully balanced pulse
        pwm_size        0.75	// how much to change pulse width
        recycle_mode    off
squ1

// put the square_wave through a low pass filter to filter out the high
// frequencies - making it less sharp.

clock
lpf1clock
        in_freq_mod1    off
        freq    	2000.00
        freq_mod1_size	0.0
lpf1clock

lp_filter
lpf1
        in_signal		squ1		out_output
        in_cutoff_degsize       lpf1clock	out_deg_size
        in_feedback     	lpf2		out_wet_output
        in_feedback_mod 	off	// input to modulate feedback level
        feedback		0.40	// amount of feedback 0 ~ 1.0
        feedback_modsize        0.00	// modulation size 0 ~ 1.0
        wet/dry 		1.0 // 1.0 is wet 0.0 is dry
lpf1

// as you can see when using lp_filter there is no place to specify the
// cut off frequency.  So what frequencies are being filtered out?  Instead of
// specifying a frequency, the filter uses an input which is a deg_size, you
// will have noticed these using the osc_clock and waveforms.  This filter is
// filtering a signal of a waveform which runs at the frequency of osc3, and
// the cutoff frequency is specified in lpfclock which provides the deg_size
// to the filter.  deg_size is how many degrees are equivalent to one sample 
// to produce the frequency.

// wcnt's implimentation of a lowpass filter is fairly basic.  Each sample
// processed is stored into the next space in an array.  To get the output
// the filter calculates how many samples make up the cut off frequency and
// then adds that many input samples together, and calculates the average.

// they work ok for everything except square wave forms.  I was rather 
// disturbed by what I saw.  I don't recall actually using them to filter
// squarewaves before.  The result was nothing like what I expected.  There
// were no smooth curves, and quite a lot of artifacts had been introduced.

// to get round this I've used three low pass filters.  the first (above)
// attempts to filter out frequencies above 1000 hrtz, the second filters
// the output of the first filter at a cutoff of 2000 hrtz, and the third
// also filters frequencies above 2000 hrtz, from the second's output

// the result:  smooth waveforms derived from a pulse width modulated square 
// wave, but it's barely recognisable as a square wave. feel free to argue on
// that point if you're more knowledgable than me.

clock
lpf2clock
        in_freq_mod1    off
        freq    	4000.00
        freq_mod1_size	0.0
lpf2clock

lp_filter
lpf2
        in_signal		lpf1		out_output
        in_cutoff_degsize       lpf2clock	out_deg_size
        in_feedback     	lpf3		out_wet_output	
        in_feedback_mod 	off	// input to modulate feedback level
        feedback		0.40	// amount of feedback 0 ~ 1.0
        feedback_modsize        0.00	// modulation size 0 ~ 1.0
        wet/dry 		1.0 // 1.0 is wet 0.0 is dry
lpf2

lp_filter
lpf3
        in_signal		lpf2		out_output
        in_cutoff_degsize       lpf2clock	out_deg_size
        in_feedback     	off
        in_feedback_mod 	off	// input to modulate feedback level
        feedback		0.00	// amount of feedback 0 ~ 1.0
        feedback_modsize        0.00	// modulation size 0 ~ 1.0
        wet/dry 		1.0 // 1.0 is wet 0.0 is dry
lpf3

mono_amp
amp1
	in_signal	swave	out_output
	in_amp_eg	adsr1	out_output
	in_amp_mod	seq1	out_velocity_ramp
	amplitude	2500	// 32767 is the maximum amplitude
	amp_mod_size	0.95	// how much influence velocity has in this case
	clip_level	25000	// the maximum allowed amplitude
amp1

// to create stereo panning we'll create some modules which 
// impliment an LFO to sweep left and right.

lfo_clock
lfoclock1
        in_phase_trig   seq1	out_note_on_trig
        in_freq_mod1    off
        in_freq_mod2    off
        freq    	2.0 // 2 cps	
        freq_mod1_size  0.0
        freq_mod2_size  0.0
lfoclock1

// lfoclock, is another differentation of the clock modules. it is 
// somewhere in function between the clock and the osc_clock module, with
// a phase trigger added.  I saw no reason to restrict the lfo_clock to low 
// frequency oscilations though.

sine_wave
lfowave										
	in_phase_trig	lfoclock1	out_phase_trig
	in_deg_size	lfoclock1	out_deg_size
	recycle_mode		off 				
	on_trig_reset_phase	on
	phase_cycles 1.0					
lfowave

// in order to take advantage of the lfo's ability to reset it's phase,
// the sine_wave has on_trig_reset_phase ON.

// the final part of the lfo is to impliment a delay and a ramp of the
// oscillations.  lfo_controller does that job, and a further amplitude 
// modulation can be added also.

// ramp the amount of modulation from zero at the beginning of each note,
// to increase as time progresses.

lfo_controller
lforamp
        in_trig 	seq1	out_note_on_trig
        in_waveform     lfowave	out_output
        in_amp_mod      off
        delay_time      75.0 // 75.0 ms
        ramp_time       100.0 // 100.0 ms
        start_level     0.0
        end_level       1.0
	response_time	25.0	
        amp_mod_size    0.0
lforamp

// When the start_level is zero, and the end_level is 1.0 as is the case here,
// when it is triggered, there is a sharp immediate jump.  As the intention is
// to use the lforamp for panning, this jump is unsatisfactory.  To avoid the
// digital click when triggered, the response_time is set to 25 ms to smoothly
// graduate from the end_level back to the start_level again.

panner
pan1
        in_signal       echo1	out_output
        in_pan_mod      lforamp	out_output
        pan     	0.00
        pan_mod_size    0.99
pan1

stereo_amp
amp2
	in_l		pan1	out_l
	in_r		pan1	out_r
	in_amp_eg	one		out_output
	in_amp_mod	seq1		out_velocity_ramp
	left_amplitude	7500	// 32767 is the maximum amplitude
	right_amplitude	7500	// 32767 is the maximum amplitude
	amp_mod_size	0.95	// how much influence velocity has in this case
	clip_level	32767	// the maximum allowed amplitude
amp2

panner
pan2
        in_signal       lpf3	out_output
        in_pan_mod      lforamp	out_output
        pan     	0.00
        pan_mod_size    -0.99
pan2

stereo_amp
amp3
	in_l		pan2	out_l
	in_r		pan2	out_r
	in_amp_eg	adsr1	out_output
	in_amp_mod	seq1	out_velocity_ramp
	left_amplitude	15000	// 32767 is the maximum amplitude
	right_amplitude	15000	// 32767 is the maximum amplitude
	amp_mod_size	0.95	// how much influence velocity has in this case
	clip_level	32767	// the maximum allowed amplitude
amp3

// constant signal, provides an ever-unchanging signal.

constant one value 1.0 one

mono_amp
testamp
	in_signal	lforamp	out_output
	in_amp_eg	one	out_output
	in_amp_mod	off
	amplitude	32700	// 32767 is the maximum amplitude
	amp_mod_size	0.0	// how much influence velocity has in this case
	clip_level	32767	// the maximum allowed amplitude
testamp

// because the wavfile_out module can only write two amplified signals 
// (left + right) at once, the output of amp1, amp2, and amp3 will need
// to be mixed together.  But before this is done, some mixer channels
// need to be created.

mix_chan ch1 
	in_left		amp1	out_mono 
        in_right        amp1	out_mono
ch1

mix_chan ch2
        in_left		amp2	out_left
        in_right        amp2	out_right
ch2

mix_chan ch3
        in_left		amp3	out_left
        in_right        amp3	out_right
ch3

mix_chan testch
	in_left		testamp	out_mono
	in_right	testamp	out_mono
testch

mixer
mixer1
        mixdesk
		ch1 ch2 ch3
        mixdesk
        master_level    0.70
mixer1

wavfile_out
wav1
	in_left		mixer1	out_left
	in_right	mixer1	out_right
	in_bar		time1	out_bar
	in_bar_trig	time1	out_bar_trig
	filename	basics04.wav
	start_bar	0
	end_bar		5
wav1

wavfile_out
testwav
	in_left		testamp	out_mono
	in_right	testamp	out_mono
	in_bar		time1	out_bar
	in_bar_trig	time1	out_bar_trig
	filename	basics04test.wav
	start_bar	0
	end_bar		5 
testwav


// Although there are only four bars in the sequencer, wav1 stops writing when
// bar 5 is reached because the release time of the ADSR causes audible sound 
// to last beyond the end bar 3 and into bar 4.

wcnt-1.1001/jwmsynth
